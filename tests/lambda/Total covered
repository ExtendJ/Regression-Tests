Empty parameters with empty body in assignment statement
Empty parameters with simple expression body in assignment statement
Two simple, no-parameter expressions in ternary statement
Empty parameters with simple block body in assignment statement
Single declared parameter with simple expression body in assignment statement
Single declared parameter with simple block body in assignment statement
Single inferred parameter (w/wo parenthesis) with simple expression body in assignment statement
Single inferred parameter with block expression body in assignment statement
Multiple simple declared parameters with simple expression body in assignment statement
Multiple inferred parameters with simple expression body in assignment statement
Modified declared parameter with simple expression body in assignment statement
Illegally using modifiers with inferred parameter
Illegally using mixed inferred and declared
A bit more complex lambda block body

Should cover:
Simple generic declared parameters
(int x, Callable<Integer, String> c) -> { return c.call().add(x); }
(Runnable<Double, Integer, String> r, Callable<Integer> c, int q) -> r.run() + c.call() 0 q;


Complex generic declared parameters
(Callable<T extends Comparable<? Super T<Integer>>> c) -> c.run();
(ArrayList<Callable<List<? extends T>>> a, Runnable<List<Callable<Integer, Double>, String[][]>, Double[]> r) -> r + a;

Test multiple modifiers
(public static final int i, private native ArrayList<Integer> a) -> a.add(i);

Lambda expressions pointing to lambda expressions (in different ways)
(x, y) -> x + y + z -> z + 4 - (i, j) -> i + j * 4 / i + l -> l + 5;

x -> { if(x > 4) 
		{ return 5; } 
	   else 
	   	{ return y -> y + 1; }
	 }; 

Normal cast of different lambdas
(FuncInterface)x -> x + 45 >> 3;
(FuncInterface)(int x, int y) -> { return x + y; };

Generic cast of different lambdas
(Callable<Integer>)(x, y) -> x - y + 5;
(ArrayList<Runnable<Integer, T Extends List>>) input -> input.toString();

Intersection type casts of lambdas (need to be tested in another folder too)
(Callable<Integer> & Runnable<? super T> & Clonable) x -> x + y -> y + z -> 6;
(SomeInterface & AnotherInterface)(int x, double y) -> x + y * 45 - 5;

Lambdas in method calls, especially with expression body to check that the comma works as delimiter
methodCall((x, y) -> {return x + y;}, a);
methodCall(a, (int x, int y) -> x + y + 5 / (5 - 45) >> 5, 4.5);
methodCall(f, x -> x + y -> y + z -> 6, 6);
methodCall((x, y) -> x < y, 8);
methodCall((ArrayList<Integer, Double> a, Runnable<ArrayList<String>, Integer> r) -> a.add(r) + y -> y, z);  

Ternary as the lambda expression body
b -> b ? ((i, j) -> i + j) : (x -> x + 5);

lambda in a switch case (not legal, but to check that the colon is a delimiter here)
switch(a) {
	case b -> b ? ((i, j) -> i + j) : (x -> x + 5) : break;
}